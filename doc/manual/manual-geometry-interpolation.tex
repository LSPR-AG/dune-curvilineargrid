\section{Polynomial Interpolator Class}
\label{interface-interpolator}

The interpolator class is designed to provide the mapping from local coordinates of a reference entity to its global coordinates. This mapping is constructed via Lagrange polynomials as given in section \ref{theory-lagrange}. Construction requires reference element/GeometryType, interpolatory vertex vector and interpolation order.  The correct order of interpolatory vertices is discussed in \ref{impl-gmsh-numbering-convention}. \\

\begin{mybox}
\begin{lstlisting}
  CurvilinearElementInterpolator(const ReferenceElement &refElement, const std::vector<GlobalVector> & point, InterpolatoryOrderType order)
  CurvilinearElementInterpolator(Dune::GeometryType gt, const std::vector<GlobalVector> & point, InterpolatoryOrderType order)
\end{lstlisting}
\end{mybox}

\noindent
The following functions provide basic information about the curvilinear entity: its interpolatory order, geometry type, number of degrees of freedom (aka number of interpolatory vertices), number of corners and vertices, as well extracting the coordinate of a vertex or a corner by its internal index. It is also possible to extract the vector of all interpolatory vertices in one go. Note that interpolatory vertices include corners and internal interpolatory vertices. Corners are the interpolatory vertices that correspond to the corners of the reference entity. \\

\begin{mybox}
\begin{lstlisting}
  InterpolatoryOrderType order()
  Dune::GeometryType type ()
  int dofPerOrder()
  GlobalVector vertex(InternalIndexType vertexIndex)
  std::vector<GlobalVector> vertexSet()
  int nCorner()
  GlobalVector corner(InternalIndexType cornerLinearIndex)
\end{lstlisting}
\end{mybox}

\noindent
The most essential part of the interpolator, the local-to-global mapping is available in both explicit and analytical form. In the first method, given a local coordinate, the global coordinate is calculated using the hard-coded Lagrange polynomials to save time. In the second method, the user is provided with an analytical vector of polynomials representing the map, which can afterwards be evaluated for any coordinate, as well as used as a polynomial in further analytical computations. The local-to-global map is given by $\vec{p}(\vec{r}) = \sum_i \vec{p}_i L_i (\vec{r})$ and is further discussed in \ref{theory-lagrange}. \\

\begin{mybox}
\begin{lstlisting}
  double lagrangePolynomial(InternalIndexType vertexIndex, const LocalVector &local)
  PolynomialVector interpolatoryVectorAnalytical()
\end{lstlisting}
\end{mybox}

\noindent
Finally, it is essential for grid functionality to be able to obtain subentity interpolators of this entity. The below method constructs the interpolator class for a subentity given its dimension ($subdim$) and its internal index. The implementation of this method is a little tricky, it is discussed in section 
\ref{impl-geometry-subentity-interpolator}

\begin{mybox}
\begin{lstlisting}
  template<int subdim>
  CurvilinearElementInterpolator< ctype, subdim, cdim > SubentityInterpolator(InternalIndexType subentityNo)
\end{lstlisting}
\end{mybox}







\subsection{Tests}

\noindent
For each dimension several linear and polynomial Functors are defined which act as pre-defined local-to-global maps. Then, for a simplex of each dimension there is a testing routine which is run for every applicable Functor. The tests are as follows:
\begin{itemize}
	\item For each order generate a local grid and sample the given functor to obtain global coordinates for interpolation points and thus construct the interpolator.
	\item First test requests a global coordinate for each local grid point, both using explicit function $realCoordinate$ and by evaluating the analytical polynomial provided by $interpolatoryVectorAnalytical$. Then the 3 results are compared. For this test, all 3 results must match independent of Functor and interpolation order.
	\item Second test requests a global coordinate for a random set of local coordinates, also comparing the correct result with explicit and analytical functionality. Explicit and analytical results should be equal to each other for any test since they do the same thing. However, they will match to the true result only if the polynomial order of the Functor is lower or equal to the one being tested, and most likely should fail for lower orders.
\end{itemize}

\textbf{TODO:}
\begin{itemize}
	\item The tests must be automatized such that the program throws an error if a test fails.
	\item Would be useful to test the method $SubentityInterpolators$ which is not tested at the moment, but is indirectly tested later in the LagrangeGeometry tests.
\end{itemize}