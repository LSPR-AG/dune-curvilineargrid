\section{Integration}

An important function of any entity is calculating its volume, integrating scalar and vector functions within it. In order to parametrize the integration domain, the integration is converted to local coordinates, namely
\[ \int f(\vec{x}) d^{\dim} x = \int f(\vec{r}) \mu(\vec{r}) d^{\dim} r \]
where $\vec{x}$ and $\vec{r}$ are global and local coordinates respectively, and the conversion function $\mu(\vec{r})$ is called the integration element. In the original \textit{dune-geometry} paradigm, geometry class itself does not perform any integration, but calculates the integration element$\mu(\vec{r})$. The user chooses and performs the integration over reference element by using, for example, one of the quadrature rules \textbf{[CITE QR]} provided by \textit{dune-geometry}. A standard numerical quadrature can written as a weighted sum
\[ \int f(\vec{r}) \mu(\vec{r}) d^{\dim} r = \sum_i f(\vec{r}_i) \mu(\vec{r}_i) w_i  \]
where the $r_i$ and $w_i$ are the quadrature points and weights. The sampling points and weights are a property of a quadrature rule used, and can be reused for all integrands given fixed domain and approximation order. More precisely, given a polynomial order $p$, one can construct a finite numerical quadrature, which will be exact for all functions, well approximated by polynomials of order $p$ and below. \\

\noindent
Numerical quadrature methods in practice are considerably faster than any other known method for domain dimensions $\dim \leq 3$ \textbf{[CITE]}, but they also have disadvantages. Firstly, they are inaccurate for functions that can't be approximated by reasonable order polynomials. Secondly, numerical quadratures for non-trivial domains (e.g. simplices) have so far only been calculated only to very moderate orders (~20) \textbf{[CITE]}. Finding a numerical quadrature is equivalent to finding roots of a polynomial, which is extremely hard in more than 1 dimension. One way to overcome these difficulties is to transform the integration domain to to a cuboid using a Duffy transform \textbf{[CITE]}. The advantage of the cuboid domain is that a quadrature rule can be constructed from a tensor product of 1D quadratures, thus only requiring the knowledge of 1D quadratures, which are available to a relatively high order. Quadrature rules created in this fashion have more points per order than the rules created specifically for the desired (e.g. simplex) domain. Nevertheless, they work, and they are implemented in $dune-grid$ up to order 61. There exist advanced methods to improve performance of quadrature integration (e.g. Sparse Grids \textbf{[CITE]}), but they are beyond the scope of this paper. \\

%%%\subsection{Overview of available numerical methods}
%%%
%%%\noindent
%%%Below is presented a short summary of integration method types known to us: \\
%%%
%%%\noindent
%%%\textbf{Gaussian Quadrature}: The method available in DUNE.
%%%\begin{itemize}
%%%	\item This method calculates the integral as a linear product of the integrand $f(\vec{r})$ values at specific precomputed points $\vec{r}_i$ with specific precomputed weights $w_i$, namely $I = \sum_i w_i f(\vec{r}_i)$. Thus the main advantage of this method is its computational cost, which is small for low order polynomial integrands.
%%%	\item Optimal quadrature points are only available for small dimensions. Finding such point sets for high dimension polynomials is very involved and is known to suffer from finite precision of floating point arithmetic. Alternatively, a suboptimal point distribution can be obtained from a tensor product space of 1D point distributions, whose size grows exponentially with integration dimension.
%%%	\item Gaussian Quadrature is constructed with the idea of calculating exact integrals for integrands being polynomial up to a given order. However, when integrating over a curved boundary, thte integration elemen is a square root of a polynomial, and polynomials really badly approximate square root, especially for small arguments, which can easily happen for highly curved elements. Not to mention that one, in principle, could with to integrate arbitrary (within reason) functions over the element. Thus
%%%		\subitem - Can GQ estimate integration error for non-polynomial functions?
%%%		\subitem - Can it be made hierarchical to have control over error by refinement?
%%%		\subitem - What would be the convergence rate to compare with other methods?
%%%\end{itemize}
%%%
%%%\noindent
%%%\textbf{Interpolatory adaptive refinement}: The method currently implemented in LagrangeGeometry subclass
%%%\begin{itemize}
%%%	\item - Evaluates integral over element, approximating the integrand by an interpolatory polymomials of two hierarchical orders (2 and 4 at the moment) \textbf{[IMAGE HERE]}
%%%	\item - The running integration error is approximated by the difference between the analytical integrals calculated from these two interpolatory polynomials.
%%%	\item - The higher order element is split into into sub-elements of lower order, and the integration proceeds recursively.
%%%	\item - Every time an element is split, its previous running error is subtracted from the total error, and the running errors of the sub-elements are added to the total error. Thus, the integration is terminated when total approximated error is below selected tolerance. 	
%%%		\subitem - using heap structure ordered by the approximate error of the element. This way avoids recursion, and at every iteration selects the element which has worst error, then refines it.
%%%		\subitem - When splitting, the previously calculated points are not re-calculated but hierarchically re-used by sub-elements. The sub-element only needs to be refined to a higher hierarchical order, by adding more points.
%%%	\item \textit{Possible improvement - Performance}. As the the refined element does not check if the neighboring elements are also being refined, so they both sample on the boundary twice. Does there exist a method to store/find intersection refinements faster than just compute 2nd time. Using order 4 for every new refined triangle we sample 9 new points, out of which 2 are being wasted, thus $22\%$ inefficient.
%%%\end{itemize}
%%%
%%%\noindent
%%%\textbf{Monte-Carlo integration} - according to above mentioned paper, good for dimensions 7 and above.
%%%\begin{itemize}
%%%	\item Randomly samples function over element, integral is approximated by the average over the sample
%%%	\item natural error estimate using sample standard deviation
%%%	\item Stratified Sampling: if after a set number of iterations sample error is larger than expected, then function is highly non-uniform. Split element in equal parts and continue recursively.
%%%	\item Markov Chain Monte Carlo (MCMC): Uses random walk to sample the integrand, thus concentrating the sample points where the function varies most. Can use Metropolis-Hastings to also adapt the sampling distribution.
%%%\end{itemize}
%%%
%%%\noindent
%%%\textbf{Interpolatory Spline integration} - this is just another idea...
%%%\begin{itemize}
%%%	\item Makes grid over element, cubic-interpolates all consecutive partially-overlapping segments, integrates analytically over each segment.
%%%		\subitem -tricky part 1: when interpolatory segments intersect, with what weights to take the intersecting parts
%%%		\subitem -tricky part 2: how well does this method interpolate boundaries of the element (being close to edges and faces)
%%%		\subitem -tricky part 3: how to estimate error of integration and necessary grid step?
%%%		\subitem - Any way to do the refinement or error-control?
%%%\end{itemize}


\subsection{Additional Concerns}

The integration in \textit{dune-curvilineargeometry} focuses on two additional questions:
\begin{itemize}
	\item Integrating polynomials of arbitrary order
	\item Integrating smooth functions with optimal polynomial order not known in advance.
\end{itemize}

\noindent
\textbf{Analytic Integration}\\
To address the first question, \textit{dune-curvilineargeometry} implements a polynomial class, which is stored as a sum of monomials of a given order. Integrals over monomials of a given order can be expressed analytically \textbf{[REF\_ABSTRACT]} \\

\begin{table}[h]
\centering
\begin{tabular}{l | l}
\hline
Cuboid Integrals &
\begin{tabular}{@{}c@{}}
$ \int_0^1 x^i dx = \frac{x^{i+1}}{i+1} $ \\
$ \int_0^1 \int_0^1 x^i y^j dx dy = \frac{x^{i+1} y^{j+1}}{(i+1)(j+1)} $ \\
$ \int_0^1 \int_0^1 \int_0^1 x^i y^j z^k dx dy dz = \frac{x^{i+1} y^{j+1} y^{j+1}}{(i+1)(j+1)(k+1)} $ \\
\end{tabular} \\ \hline
Simplex Integrals &
\begin{tabular}{@{}c@{}}
$ \int_0^1 \int_0^{1-x} x^i y^j dx dy = \frac{i! j!}{(i + j + 2)!} $ \\
$ \int_0^1 \int_0^{1-x} \int_0^{1-x-y} x^i y^j z^k dx dy dz = \frac{i! j! k!}{(i + j + k + 3)!} $ \\
\end{tabular} \\
\end{tabular} \\
\end{table}

\noindent
We provide a method to integrate over a reference element in the polynomial class. It is exact and works simply by summing the analytical monomial integrals given above for all monomial summands. \\

\noindent
\textbf{Adaptive Integration}\\
In its most general form a scalar integral over an element can be written as \[\int f(\vec{r}) d^{\dim} x = \int f(\vec{r}) \mu(\vec{r}) d^{\dim} r,\] where the integration element $\mu(\vec{r})$ can most generally be written as \[\mu(\vec{r}) = \sqrt{\det(J J^T)},\] where $J$ is the Jacobian matrix. \\

\noindent
In the case of matching element and space dimension (like volume in 3D, and area in 2D), the integration element simplifies to $|\det J|$. Even though absolute value is not a polynomial function, it can be observed that $\det J$ is not allowed to change sign over the element for any sensible non-self-intersecting geometries. Even if $\det J = 0$ somewhere within the element, it would mean that a finite volume element inside reference element is mapped to a 0 volume in real space, which should be avoided by meshing tool. Therefore, in this case, $\det J$ will always have the same sign. It remains to evaluate it anywhere inside the element, and multiply by -1 if it is negative. Then the integration of scalar polynomial function over this integration element can be done exactly. \\

\noindent
In the case of mismatching dimensions (like area in 3D, and length in 2D and 3D), the expression for $\mu(\vec{r})$ can not be simplified, and therefore the integrand is a square root of a polynomial. This integral cannot be done analytically, and therefore requires a numerical method. Currently, \textit{dune-curvilineargeometry} provides a recursive integrator, which iteratively increases the quadrature order until the estimated integration error converges to a desired tolerance. This method can take several seconds if the integrand requires very high polynomial order, but for low order integrands it converges much faster.

\noindent
Still, there is definitely room for improvement. According to \textbf{[PAPER]} best results in low-dimensional numerical integration are achieved by adaptive quadrature of high degree, whereas Monte-Carlo methods are best for high-dimensional integrals. Thus, using an external adaptive library, for example the GSL extension from \url{http://ab-initio.mit.edu/wiki/index.php/Cubature}, could be of definite advantage. It is based on Clenshaw-Curtis quadrature, which has the advantage of being hierarchical, and thus can be refined to iteratively improve precision withouth having to sacrifice previous sample points. Another speedup could be provided by employing sparse grids \textbf{[CITE]} \\

%%%\subsection{Integration Element - Vector}
%%%
%%%When integrating vector functions we are mostly interested in the integrals over boundary surfaces and edges, namely $\int_{\partial V} \vec{f}(\vec{r}) \cdot \vec{n}(\vec{r}) d(\partial V)$. For an edge in 2D the following expression for the tangential and normal integration elements (up to a sign convention) can be found:
%%%\[ d\vec{l}_{\parallel} = (\partial_u p_x, \partial_u p_y)du \; \; \; \; \; d\vec{l}_{\perp} = (\partial_u p_y, -\partial_u p_x)du  \]
%%%
%%%\noindent
%%%For a vector in 3D the tangential integration element is not defined, but the normal integration element is
%%%\[ d\vec{S} = (\partial_u \vec{p} \times \partial_v \vec{p})du \; dv  \]
%%%
%%%\noindent
%%%Thus, given polynomial vector basis functions $\vec{f}$ and polynomial interpolation, the scalar (and, if necessary, vector) products $\vec{f}(u) \cdot d\vec{l}(u)$ and $\vec{f}(u,v) \cdot d\vec{S}(u,v)$ are also polynomial, and can be integrated exactly using analytic polynomial integration code.