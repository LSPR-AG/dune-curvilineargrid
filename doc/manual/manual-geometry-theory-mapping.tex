\section{Coordinate transformation}

In order to calculate the coordinate transformation properties, one requires the knowledge of the local-to-global map $\vec{p}(\vec{r})$ and its first partial derivatives. Currently, only the Lagrange Polynomials themselves are provided as hard-coded expressions, but their derivatives are not yet available as hard-coded quantities, and thus are extracted from the analytical map.

\subsection{Jacobian and JacobianInverse}

We construct the local-to-global map using the polynomial class, ant hence compute the Jacobian $J_{ij}(\vec{r}_0) = \partial_{r_i} p_j (\vec{R}) |_{\vec{r}_0}$. The inverse and integration element of the element are computed numerically, using Dune-MatrixHelper to invert matrix and calculate the pseudodeterminant $dI = \sqrt{\det(JJ^T)}$. \\

\subsection{Local-to-Global mapping}

To accelerate the calculation, the local-to-global map is computed numerically using hard-coded Lagrange polynomials

\subsection{Global-to-Local mapping}

The global-to-local method inverts the above map, and finds the local coordinate of this entities geometry that corresponds to the requested global coordinate. However, this is not always possible:
\begin{itemize}
	\item Local coordinate is only defined for a global coordinate which happens to be inside of the element. Even for most simple polynomial maps, there exist global coordinates which do not correspond to any local coordinate at all. For example, $x^2$ is a perfectly valid local-to-global map for an edge defined on $[0,1]$. However, no local coordinate at all corresponds to the global coordinate $-1$. Therefore, if there is high evidence that a point is located outside the element, the method simply reports that the coordinate is outside, and does not report a local coordinate.
	\item Local coordinate is only defined when $(dim_{elem} = dim_{world})$. For unequal dimensions, disregarding the question being a tedious computational task, it is also somewhat meaningless. The probability that a randomly selected point would belong to an infinitely thin object is negligibly small. 
\end{itemize}

\noindent
Even for $(dim_{elem} = dim_{world})$, this is still a very tricky problem. Since the map from local to global is polynomial, it is in principle non-invertible, at least not in terms of standard functions. It can be guaranteed that the map is one-to-one within the element, otherwise the the real element geometry would be self-intersecting, which is ensured to not be the case by meshing software when selecting interpolation points. However, there are no obvious reasons why the geometry should not be self-intersecting outside the element, which means that the map need not be one-to-one outside the element. \\

\noindent
For obvious reasons we will not solve the problem directly, as searching for roots of a system of polynomial equations with several parameters is a very challenging task \textbf{[POLYNOMIAL ROOTS PAPERS]}. Instead, the problem is solved by a Newton method \textbf{[CITE]}, originally implemented in dune-multilinear geometry:
\begin{itemize}
	\item Let $\vec{x}_0$ be the requested global coordinate
	\item Start with a local point $\vec{r}_0$ guaranteed to be inside the element (e.g. its center),
	\item Iteratively choose better approximations for local coordinate using \[\vec{r}_{n+1} = \vec{r}_n + \vec{d}(\vec{r}_n)\] where $\vec{d}(\vec{r}_n)$ is the solution of
	        \[ J(\vec{r}_n) \vec{d}(\vec{r}_n) = \vec{p}(\vec{r}_n) \] and $J(\vec{r})$ is the Jacobian matrix.
	\item We finish the iterative process, if the global coordinate converges in terms of the two-norm
	        \[\Delta_i = \{ |\vec{p}(\vec{r}_i) - \vec{x}_0 |^2 \}. \]
	\item We also terminate the iteration if it is suspected that the vertex is outside the element. For this we use two criteria: the current iteration being far outside the element \[|\vec{p}_0 - \vec{p}_i|_2 > 4 R_{elem}\] and the convergence being slower than expected \[ 2 \Delta_{i + 10} > \Delta_{i} \]
\end{itemize}

\noindent
We are still looking to improve this method. It correctly predicts the global coordinates being inside and outside the element for most of our tests, but fails to identify the boundary points inside the element for certain cases. We warmly welcome suggestions on this question.