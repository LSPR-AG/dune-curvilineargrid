\subsection{Coordinate transformation}

In order to calculate the coordinate transformation properties, one requires the knowledge of the local-to-global map $\vec{p}(\vec{r})$ and its first partial derivatives. Currently, only the Lagrange Polynomials themselves are provided as hard-coded expressions, but their derivatives are not yet available as hard-coded quantities, and thus are extracted from the analytical map. \\

\noindent
\textbf{Jacobian and JacobianInverse}.
We construct the local-to-global map using the polynomial class, and then compute the Jacobian $J_{ij}(\vec{r}_0) = \partial_{r_i} p_j (\vec{R}) |_{\vec{r}_0}$ using partial differentiation of the polynomial class. This results in a matrix of polynomials, which can be evaluated for the desired local coordinate(s). The inverse and integration element of the element are computed numerically, using Dune-MatrixHelper to invert matrix and calculate the pseudodeterminant $dI = \sqrt{\det(JJ^T)}$. \\

\noindent
\textbf{Local-to-Global mapping}
This is the map that defines the curvature of the element via Lagrange Interpolation. To accelerate the calculation, the local-to-global map is computed numerically using hard-coded Lagrange polynomials \\

\noindent
\textbf{Global-to-Local mapping}
The global-to-local method inverts the above map, and finds the local coordinate (of the entity geometry) $\vec{r}$ that corresponds to the requested global coordinate $\vec{x}$. Further, this method is extended to elements with $(dim_{elem} \leq dim_{world})$ by converting it to an optimization problem
\begin{equation}
  \label{eq-theory-mapping-optimization}
  \vec{r} : |\vec{p}(\vec{r}) - \vec{x} |^2 \rightarrow \min
\end{equation} 
searching for the local coordinate closest to the inverse of the desired global coordinate in terms of distance in global coordinates. \\

\noindent
While this problem is always uniquely solvable in linear case, in curvilinear case it experiences several additional challenges
\begin{itemize}
	\item Polynomial interpolatory map $\vec{p}(\vec{r})$ is strictly bijective inside the reference element, which must be ensured by the mesh generator. However, this need not be the case outside it. For example, $p(r) = r^2$ is a perfectly valid 1D local-to-global map for an edge defined on $[0,1]$. However, the map is clearly non-invertible for all $p(r) \leq 0$.
	\item Curvilinear geometries have singularities, like $r = 0$ in the previous example. At these points Jacobian determinant changes sign, and the volume element is zero. Simple iterative methods break down in the viscinity of singularities. 
	\item For $(dim_{elem} \leq dim_{world})$, the optimization problem \ref{eq-theory-mapping-optimization} is non-convex. It can have multiple solutions, even uncountably many.
\end{itemize}

\noindent
For obvious reasons we will not solve the problem directly, as searching for roots of a system of polynomial equations with several parameters is a very challenging task \cite{canny+1989}. Instead, the problem is solved by a first order Gauss-Newton method \cite{bjoerck+1996}, originally implemented in dune-multilinear geometry.

\noindent
After having discussions with potential users, we have realised that in order to satisfy all use cases there is a need to implement two distinct methods
\begin{itemize}
  \item Restrictive method. This method will be useful for those who want to find the element containing the global coordinate, as well as the local coordinate inside that element. If the provided global coordinate is inside the element, the method will return true and a valid local coordinate. Otherwise, it will simply return false and no coordinate at all. This method also extends to lower dimension entities, finding the local coordinate which optimizes the distance within the element. Given well-defined map, this method is guaranteed fo finish.
  \item Non-restrictive method. This method will be useful for those who wish to extrapolate the global-to-local map beyond the reference element. This method searches for the inverse (or the distance minimizer) over the entire local domain. This is a best effort method - due to the above mentioned difficulties, it will frequently fail to find an acceptible solution. In this case, an exception is thrown.
\end{itemize}

\noindent
Below we briefly present the algorithm of the restrictive method:
\begin{enumerate}
	\item Let $\vec{x}_0$ be the requested global coordinate
	\item Start with a local point $\vec{r}_0$ guaranteed to be inside the element (e.g. its center),
	\item Iteratively choose better approximations for local coordinate using \[\vec{r}_{n+1} = \vec{r}_n + \vec{d}(\vec{r}_n)\] where $\vec{d}(\vec{r}_n)$ is the solution of
	        \[ J(\vec{r}_n) \vec{d}(\vec{r}_n) = \vec{p}(\vec{r}_n) \] and $J(\vec{r})$ is the Jacobian matrix.
	\item We finish the iterative process, if the global coordinate converges in terms of the two-norm
	        \[\Delta_i = \{ |\vec{p}(\vec{r}_i) - \vec{x}_0 |^2 \}. \]
	\item We also terminate the iteration if it is suspected that the vertex is outside the element. For this we use two criteria: the current iteration being far outside the element \[|\vec{p}_0 - \vec{p}_i|_2 > 4 R_{elem}\] and the convergence being slower than expected \[ 2 \Delta_{i + 10} > \Delta_{i} \]
\end{enumerate}

\noindent
We are still looking to improve this method. It correctly predicts the global coordinates being inside and outside the element for most of our tests, but fails to identify the boundary points inside the element for certain cases. We warmly welcome suggestions on this question.