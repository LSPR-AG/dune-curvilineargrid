\noindent
In order to learn the workings of curvilinear grid it is easiest to study the source code of relevant tutorials \index{tutorial} provided inside the curvilinear grid module.

\subsection{Tutorial 1 - Getting started}
\label{usage-howto-tutorial-gettingstarted}

\noindent
In this tutorial we will create a Curvilinear Grid by reading it from a GMSH file. This and all other tutorials can be run both in serial and in parallel. First we define the grid \\

\begin{mybox}
\begin{lstlisting}
  typedef Dune::CurvilinearGrid<ctyoe, dim, isCached> GridType;
\end{lstlisting}
\end{mybox}

\noindent
where $dim=3$ is the dimension of the grid, $ctype=double$ is the underlying real type, and the $isCached$ is a bool variable determining if the curvilinear geometry caching is used (recommended). Currently, only 3D grids are available. Then the curvilinear grid is created by a short $createGrid$ procedure.  \\

\noindent
Firstly, the the logging functionality is initialized. These singleton classes allow the grid to write parallel text output, as well as report parallel timing statistics on the different stages of grid constructon. They can also be used by the user to write user logging output and time user functions, comparing them to the grid construction time. \\

\begin{mybox}
\begin{lstlisting}
  Dune::LoggingMessage::getInstance().init(mpihelper);
  Dune::LoggingTimer<Dune::LoggingMessage>::getInstance().init(mpihelper);
\end{lstlisting}
\end{mybox}

\noindent
Afterwards, we construct the Curvilinear Grid Factory \\

\begin{mybox}
\begin{lstlisting}
  Dune::CurvilinearGridFactory<GridType> factory(withGhostElements, withGmshElementIndex, mpihelper);
\end{lstlisting}
\end{mybox}

\noindent
where $bool\ withGhostElements$ defines whether the Ghost Elements will be constructed and $bool\ withGmshElementIndex$ determines if the global element index from GMSH is going to be reused by the grid (recommended). \\

\noindent
Then the Parallel Curvilinear GMSH Reader is used to read the mesh into the factory. \\

\begin{mybox}
\begin{lstlisting}
  Dune::CurvilinearGmshReader< GridType >::read(factory, filename, mpihelper); 
\end{lstlisting}
\end{mybox}

\noindent
where $filename$ is the name of the $.msh$ file \\

\noindent
The factory is used to create the grid and return a pointer to it \\
\begin{mybox}
\begin{lstlisting}
  factory.createGrid();
\end{lstlisting}
\end{mybox}

If we are interested in the time it took for different processes to construct different parts of the grid, this statistics can be obtained using \\

\begin{mybox}
\begin{lstlisting}
  LoggingTimer::getInstance().reportParallel(mpihelper);
\end{lstlisting}
\end{mybox}



\subsection{Tutorial 2 - Traverse}
\label{usage-howto-tutorial-traverse}

This tutorial repeats the procedure from tutorial 1 to create the grid. Afterwards, it iterates over the grid and extracts relevant information from the curvilinear entities. Currently, there is no refinement, so only leaf iterators are available, which are defined using the Dune 2.4 $auto \&\&$ standard. The below iterator will iterate over all entities of the grid of a given codimension \\

\begin{mybox}
\begin{lstlisting}
  LeafGridView leafView = grid.leafGridView();
  for (auto&& elementThis : entities(leafView, Dune::Dim<dim - codim>())) {...}
\end{lstlisting}
\end{mybox}


Now we would like to extract some relevant information from the iterator \\
\begin{mybox}
\begin{lstlisting}
  Dune::GeometryType gt = elementThis.type();
  LocalIndexType  localIndex = grid.leafIndexSet().index(elementThis);
  GlobalIndexType globalIndex = grid.template entityGlobalIndex<codim>(elementThis);
  PhysicalTagType physicalTag = grid.template entityPhysicalTag<codim>(elementThis);
  InterpolatoryOrderType interpOrder = grid.template entityInterpolationOrder<codim>(elementThis)
	
  BaseGeometry geom = grid.template entityBaseGeometry<codim>(elementThis);
  std::vector<GlobalCoordinate> interpVertices = geom.vertexSet();
\end{lstlisting}
\end{mybox}

\noindent
The $GeometryType$ and $LocalIndex$ are standard in Dune. $GlobalIndex$ provides a unique integer for each entity of a given codimension, over all processes. $PhysicalTag$ is the tag associated with the entity as defined in GMSH. It can be used to relate to the material property of the entity, or to emphasize its belonging to a particular subdomain. Originally this information was only available for extraction through the reader directly. $InterpolatoryOrder$ is an integer denoting the polynomial interpolation order of the geometry of the entity. It is allowed to take values 1 to 5. The $entityBaseGeometry$ gives user direct access to the curvilinear geometry class of the entity, thus extending the interface provided by Dune::Grid::Geometry. For example, it can be used to obtain the set of interpolatory vertices of the geometry. \\






\subsection{Tutorial 3 - Visualisation}
\label{usage-howto-tutorial-visualisation}

This tutorial demonstrates a simple way to output the curvilinear grid and associated vector fields (e.g. solutions of your PDE) to PVTU file set using our CurvilinearVTKGridWriter. We write 2 example fields over the same mesh - sinusoid, defined in local coordinates of the element, and sinusoid, defined in global coordinates of the world. This tutorial also teaches us several important things:
\begin{itemize}
	\item Local fields are unique for each element, whereas global fields are independent of the element considered.
	\item Local fields are associated with the orientation of the element in space, which can be arbitrary. Thus, to correctly display local fields, one must consider the orientation of the element. This can be achieved by considering the global coordinates and/or global indices of the corner vertices of the element.
\end{itemize}

\noindent
We start by constructing a curvilinear geometry same as in the first tutorial. We then proceed to initialize the writer, as well as fix its virtual refinement order to 15. We do this, because we want to resolve the details of the sinusoid function as good as possible, and because the mesh size is small. This operation is very expensive. Should we choose to avoid specifying a fixed refinement order, the writer will calculate this order itself by considering the curvilinear order of the element. This should be fine for most FEM applications, unless the basis order of the element is larger than its curvilinear order. \\

\begin{mybox}
\begin{lstlisting}    
  Dune::CurvilinearVTKGridWriter<GridType> writer(*grid);
    
  const int userDefinedVirtualRefinement = 15;
  writer.useFixedVirtualRefinement(userDefinedVirtualRefinement);
\end{lstlisting}
\end{mybox}

\noindent
We proceed to define a vector of function pointers - the sinusoid functions we would like to plot over each element. \\

\begin{mybox}
\begin{lstlisting}    
  std::vector<DuneVTKFunction *> vtkFuncSet_;
  vtkFuncSet_.push_back(new VTKFunctionLocalSinusoid<GridType>());
  vtkFuncSet_.push_back(new VTKFunctionGlobalSinusoid<GridType>(*grid));
\end{lstlisting}
\end{mybox}
	
\noindent
The functions must obey the Dune::VTKFunction standard, defining the following methods: \\

\begin{mybox}
\begin{lstlisting}    
  // Number of components of the field (3 in 3d)
  virtual int ncomps() const  { .... }
  
  // Component of the field f[comp] of the element, evaluated at a local coordinate xi
  virtual double evaluate(int comp, const EntityElement & element, const LocalCoordinate &xi) const {... }
  
  // Name of the function
  virtual std::string name() const { }
\end{lstlisting}
\end{mybox}



\subsection{Tutorial 4 - Quadrature Integration Tutorial}
\label{usage-howto-tutorial-integration-quadrature}

\paragraph{Surface Projection Integral - Gauss Law}
Here we demonstrate a way to integrate a function over the boundary of the domain. In this example we are going to check Gauss law by computing the surface integral of the electric field of a unit point charge across the domain boundary of the mesh enclosing that charge. The tutorial will demonstrate that changing the curvature of the domain boundary does not affect the result. \\

\noindent
We would like to compute the integral
\[\int_{\delta \Omega} \vec{E}(\vec{x}) \cdot d\vec{S} = \int_{\delta \Omega} \vec{E}(\vec{x}(\vec{u})) \cdot \vec{n}(\vec{u}) \Delta J(\vec{u}) d^2 u \]
\noindent
where $\vec{x}$ is the global coordinate, $\vec{u}$ is the coordinate local to the surface finite element, $\vec{E}(\vec{x}) = |\vec{x}|^{-2} \vec{e}_r$ is the electric field of a unit charge located at the origin of global coordinates, $\vec{n}(\vec{u})$ is the surface outer normal in global coordinates as function of local coordinate and $\Delta J(\vec{u}) = \sqrt{\det [ J^T(\vec{u}) J(\vec{u}) ]}$ is the generalized integration element which comes from conversion of the integral from global to local coordinates. \\

\noindent
Below we present a functor which calculates the integrand for the above integral for a given boundary face. We initialize it with the intersection class, as it contains all the necessary information to perform the calculation. The function $ChargeField(x)$ calculates $\vec{E}(\vec{x})$. The important is the $operator()(x)$, which calculates the integrand. Given a local coordinate, it first finds integration outer normal at that point, which is equivalent to $\vec{n}(\vec{u}) \Delta J(\vec{u})$. Then it calculates the associated global coordinate and the field at that global coordinate. Finally, it returns the scalar product between the integration normal and the field \\


\begin{mybox}
\begin{lstlisting}
  template<class Grid, int mydim>
  struct GaussFunctor
  {
    typedef Dune::FieldVector<double, mydim>  LocalCoordinate;
    typedef typename Grid::Traits::LeafIntersection               Intersection;
    typedef Dune::FieldVector<double, DIM_SCALAR>  ResultType;

    Intersection I_;

    GaussFunctor(const Intersection & I) : I_(I)  {}

    static GlobalCoordinate ChargeField(const GlobalCoordinate & x)
    {
      GlobalCoordinate rez = x;
      rez /= pow(x.two_norm2(), 1.5);
      return rez;
    }

    ResultType operator()(const LocalCoordinate & x) const
    {
      GlobalCoordinate integrnormal = I_.integrationOuterNormal(x);
      GlobalCoordinate global = I_.geometry().global(x);
      GlobalCoordinate field = ChargeField(global);

      double rez = 0;
      for (int i = 0; i < 3; i++) { rez += integrnormal[i] * field[i]; }
      return ResultType(rez);
    }
  };
\end{lstlisting}
\end{mybox}

\noindent
Now, in order to calculate the Gauss law integral, the above functor needs to be calculated for all domain boundary segments and integrated over the reference element (reference triangle for simplex meshes). Thus, the code iterates over all elements of the mesh, then over all intersections, then constructs the above functor using each intersection that does not have a neighbour, and integrates it over the reference element using the gradually approximating quadrature as given in \ref{interface-integrator-quadrature}. \\

\begin{mybox}
\begin{lstlisting}
  double gaussintegral = 0.0;
  double rel_tol = 1.0e-5;

  typedef Dune::QuadratureIntegrator<double, 2, 1>  Integrator2DScalar;
  typedef Dune::QuadratureIntegrator<double, 2, 3>  Integrator2DVector;

  LeafGridView leafView = grid.leafGridView();
  EntityLeafIterator ibegin = leafView.template begin<0>();
  EntityLeafIterator iend   = leafView.template end<0>();

  for (EntityLeafIterator it = ibegin; it != iend; ++it)
  {
    const Entity &entity = *it;
    const IntersectionIterator nend = leafView.iend(entity);
    for( IntersectionIterator nit = leafView.ibegin(entity); nit != nend; ++nit )
    {
      const Intersection &intersection = *nit;

      if (!intersection.neighbor())
      {
        Dune::GeometryType gt = intersection.type();
        GaussFunctor<GridType, 2> f(intersection);
        Dune::QuadratureIntegrator<double, 2> qInt;
        StatInfo thisIntegral = Integrator2DScalar::integrateRecursive(gt, f, rel_tol).second;
        gaussintegral += thisIntegral;
      }
    }
  }
\end{lstlisting}
\end{mybox}

\noindent
The StatInfo is a return data-type of the QuadratureIntegrator, which is a pair of the integral result, and the quadrature order at which it converged \\


\paragraph{Surface Vector Integral - Normal Integral}
\noindent
The QuadratureIntegrator is designed to be able to integrate both scalar and vector quantities over a reference element. When integrating a vector quantity, all components of the vector are summed up individually with the same weights. This functionality can be used to calculate the integral of a normal over a closed domain. The integral of each component of the normal can be shown to be zero for all closed domains, so the integral should amount to zero vector.

\begin{equation}
	\oiint_{\partial \Omega} n_x dS = \oiint_{\partial \Omega} \vec{e}_x \cdot \vec{n} dS = \iiint_{\Omega} \nabla \cdot \vec{e}_x dV = 0
\end{equation}

\noindent
To perform this integral, we construct a functor which computes a normal to the intersection given the intersection and coordinate. \\

\begin{mybox}
\begin{lstlisting}
  template<class Grid, int mydim>
  struct NormalFunctor
  {
	typedef Dune::FieldVector<double, mydim>         LocalCoordinate;
	typedef typename Grid::Traits::LeafIntersection  Intersection;

	Intersection I_;

	NormalFunctor(const Intersection & I) : I_(I)  { }

	GlobalCoordinate operator()(const LocalCoordinate & x) const
    {
      return I_.integrationOuterNormal(x);
    }
  };
\end{lstlisting}
\end{mybox}

Integration of a vector quantity is done the same way as the integration of a scalar quantity in the first example, namely \\

\begin{mybox}
\begin{lstlisting}
  NormalFunctor<GridType, 2> n(intersection);
  StatInfo thisIntegralN = Integrator2DVector::integrateRecursive(gt, n, rel_tol);
\end{lstlisting}
\end{mybox}



%\subsection{Tutorial 4 - Recursive Numerical Integration}
%\label{usage-howto-tutorial-integration-recursive}

%%\subsection{Tutorial 5 - Polynomial Manipulation and Integration}
%%\label{usage-howto-tutorial-polynomial}
%%
%%\subsection{Tutorial 6 - Communication}
%%\label{usage-howto-tutorial-communication}
%%
%%\paragraph{Determining communicating entities}
%%
%%In this tutorial we explicitly select all entities of the grid that are supposed to communicate for each communication procedure, and communicate a dummy constant. The goal is to confirm that all the expected entities were communicated over, and all other were not. \\
%%
%%\noindent
%%Briefly, the procedure communicateConstant iterates over all process process boundary intersections, and marks its neighbour entities, if they will be sending or receiving within the provided interface. Then the custom DataHandleConst is used to perform the communication. This data handle communicates one and the same constant to all entities it is requested. The important thing is that whenever gather or scatter methods are called, it checks if the requested entity was marked for sending or receiving, and throws an error if it is not. Finally, the main procedure checks that the total number of entities that have received the constant is equal to the number of entities marked for receiving.
%%
%%
%%\paragraph{Communicating global Id}
%%
%%In this simple example, a global Id of each entity is communicated, and compared to the global Id on the receiving side. An error is thrown if they mismatch.
%%
%%
%%
%%\subsection{Tutorial 7 - Point Location - OCTree}
%%\label{usage-howto-tutorial-octree}










