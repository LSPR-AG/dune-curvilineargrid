\section{Usage (Curvilinear Grid How-to)}
\label{usage-howto}

In order to learn the workings of curvilinear grid it is easiest to study the source code of relevant tutorials \index{tutorial} provided inside the curvilinear grid module.

\subsection{Tutorial 1 - Getting started}
\label{usage-howto-tutorial-gettingstarted}

In this tutorial we will create a Curvilinear Grid by reading it from a GMSH file. This and all other tutorials can be run both in serial and in parallel.
First we define the grid \\

\begin{mybox}
\begin{lstlisting}
  typedef Dune::CurvilinearGrid<dim, dimworld, ctype> GridType;
\end{lstlisting}
\end{mybox}

\noindent
where $dim=3$ and $dimworld=3$ are dimensions of the grid and the world containing the grid. Currently this is the only allowed setup. \\

\noindent
Afterwards, we construct the Curvilinear Grid Factory \\

\begin{mybox}
\begin{lstlisting}
  Dune::CurvilinearGridFactory<GridType> factory(withGhostElements, verbose, processVerbose, mpihelper);
\end{lstlisting}
\end{mybox}

\noindent
where $bool\ withGhostElements$ defines whether the Ghost Elements will be constructed. $bool\ verbose,\ processVerbose$ determine the master process and all other processes would write the debug output. \\

\noindent
Then the Parallel Curvilinear GMSH Reader is used to read the mesh into the factory. \\

\begin{mybox}
\begin{lstlisting}
    Dune::CurvilinearGmshReader< GridType >::read(factory, filename, mpihelper, verbose, processVerbose, writeReaderVTKFile, insertBoundarySegment); 
\end{lstlisting}
\end{mybox}

\noindent
where $filename$ is the name of the $.msh$ file. $bool\ writeReaderVTKFile$ option allows to write the mesh to parallel VTU files immediately after reading. $bool\ insertBoundarySegment$ enables inserting boundary segments from the GMSH file. Currently the switch must be true, and $.msh$ file must contain all boundary segments for the grid to work. \\

\noindent
Finally, the factory is used to create the grid and return a pointer to it \\
\begin{mybox}
\begin{lstlisting}
  factory.createGrid();
\end{lstlisting}
\end{mybox}


\subsection{Tutorial 2 - Traverse}
\label{usage-howto-tutorial-traverse}

This tutorial repeats the procedure from tutorial 1 to create the grid, after which it iterates over the grid and extracts relevant information from the curvilinear entities. Currently, there is no refinement, so only leaf iterators are available, which are defined the usual Dune way given a codimension $codim$ of the entities\\

\begin{mybox}
\begin{lstlisting}
  typedef typename LeafGridView::template Codim<codim>::Iterator EntityLeafIterator;
  EntityLeafIterator ibegin = leafView.template begin<codim>();
  EntityLeafIterator iend   = leafView.template end<codim>();
  
  for (EntityLeafIterator it = ibegin; it != iend; ++it) {...}
\end{lstlisting}
\end{mybox}


Now we would like to extract some relevant information from the iterator \\
\begin{mybox}
\begin{lstlisting}
  Dune::GeometryType gt              = it->type();
  LocalIndexType  localIndex         = grid.leafIndexSet().index(*it);
  GlobalIndexType globalIndex        = grid.template entityGlobalIndex<codim>(*it);
  PhysicalTagType physicalTag        = grid.template entityPhysicalTag<codim>(*it);
  InterpolatoryOrderType interpOrder = grid.template entityInterpolationOrder<codim>(*it);
\end{lstlisting}
\end{mybox}

The $GeometryType$ and $LocalIndex$ are standard in Dune. $GlobalIndex$ provides a unique integer for each entity of a given codimension, over all processes. $PhysicalTag$ is the tag associated with the entity as defined in GMSH. It can be used to relate to the material property of the entity, or to emphasize its belonging to a particular subdomain. Originally this information was only available for extraction through the reader directly. $InterpolatoryOrder$ is an integer denoting the polynomial interpolation order of the geometry of the entity. It is allowed to take values 1 to 5. \\






\subsection{Tutorial 3 - Visualisation}
\label{usage-howto-tutorial-visualisation}

Curvilinear VTK writer is a tool capable of writing curvilinear geometries to VTK, VTU and PVTU files. It has the following features
\begin{itemize}
	\item Works in serial and parallel
	\item Writes curvilinear edges, triangles and tetrahedra
	\item Curvilinear entities are discretized into sets of linear edges / triangles, which are then written
	\item Writes following parameters for each entity
	  \subitem - process rank    - the rank of containing process
	  \subitem - physical tag    - an integer associated with with each entity, for example its material property
	  \subitem - structural type - an integer which distinguishes between different partition types of the entity, such as Internal, Ghost, Domain and Process Boundaries
\end{itemize}

\noindent
Creation of the grid and extraction of its parameters is done in the same way as in tutorial 2. To write the VTK output, first the writer class needs to be initialized \\

\begin{mybox}
\begin{lstlisting}
  Dune::CurvilinearVTKWriter<GridType> vtkCurvWriter(verbose, processVerbose, mpihelper);
\end{lstlisting}
\end{mybox}

\noindent
Afterwards, the tags vector needs to be created by combining the parameters discussed above

\begin{mybox}
\begin{lstlisting}
  std::vector<int> tags  { physicalTag, structType, mpihelper.rank() };
\end{lstlisting}
\end{mybox}

\noindent
Now each entity of dimension $mydim$ is added to the writer using the command below. The corresponding parameters are described in the \textbf{[WRITER]} section. \\

\begin{mybox}
\begin{lstlisting}
  vtkCurvWriter.template addCurvilinearElement<mydim>(gt, interpVertices, tags, interpOrder, N_DISCRETIZATION_POINTS, interpolate, explode, WRITE_VTK_EDGES, WRITE_VTK_TRIANGLES);
\end{lstlisting}
\end{mybox}

\noindent
Finally, the data needs to be written to a file. For this one of the following 3 routines can be used \\

\begin{mybox}
\begin{lstlisting}
  vtkCurvWriter.writeVTK(filename);
  vtkCurvWriter.writeVTU(filename);
  vtkCurvWriter.writeParallelVTU(filename_without_extension);
\end{lstlisting}
\end{mybox}

\noindent
The first two would write the output into the specified VTK and VTU files correspondingly. The third one would write a VTU file and a PVTU file if on master process, and only VTU file if on any other process.




\subsection{Tutorial 4 - Quadrature Integration Tutorial}
\label{usage-howto-tutorial-integration-quadrature}

Here we demonstrate a way to integrate a function over the boundary of the domain. In this example we are going to check Gauss law by computing the surface integral of the electric field of a unit point charge across the domain boundary of the mesh enclosing that charge. The tutorial will demonstrate that changing the curvature of the domain boundary does not affect the result. \\

\noindent
We would like to compute the integral
\[\int_{\delta \Omega} \vec{E}(\vec{x}) \cdot d\vec{S} = \int_{\delta \Omega} \vec{E}(\vec{x}(\vec{u})) \cdot \vec{n}(\vec{u}) \Delta J(\vec{u}) d^2 u \]
\noindent
where $\vec{x}$ is the global coordinate, $\vec{u}$ is the coordinate local to the surface finite element, $\vec{E}(\vec{x}) = |\vec{x}|^{-2} \vec{e}_r$ is the electric field of a unit charge located at the origin of global coordinates, $\vec{n}(\vec{u})$ is the surface outer normal in global coordinates as function of local coordinate and $\Delta J(\vec{u}) = \sqrt{\det [ J^T(\vec{u}) J(\vec{u}) ]}$ is the generalized integration element which comes from conversion of the integral from global to local coordinates. \\

\noindent
Below we present a functor which calculates the integrand for the above integral for a given boundary face. We initialize it with the intersection class, as it contains all the necessary information to perform the calculation. The function $ChargeField(x)$ calculates $\vec{E}(\vec{x})$. The important is the $operator()(x)$, which calculates the integrand. Given a local coordinate, it first finds integration outer normal at that point, which is equivalent to $\vec{n}(\vec{u}) \Delta J(\vec{u})$. Then it calculates the associated global coordinate and the field at that global coordinate. Finally, it returns the scalar product between the integration normal and the field \\


\begin{mybox}
\begin{lstlisting}
  template<class Grid, int mydim>
  struct GaussFunctor
  {
    typedef Dune::FieldVector<double, mydim>  LocalCoordinate;
    typedef typename Grid::Traits::LeafIntersection               Intersection;

    Intersection I_;

    GaussFunctor(const Intersection & I) : I_(I)  {}

    static GlobalCoordinate ChargeField(const GlobalCoordinate & x)
    {
      GlobalCoordinate rez = x;
      rez /= pow(x.two_norm2(), 1.5);
      return rez;
    }

    double operator()(const LocalCoordinate & x) const
    {
      GlobalCoordinate integrnormal = I_.integrationOuterNormal(x);
      GlobalCoordinate global = I_.geometry().global(x);
      GlobalCoordinate field = ChargeField(global);

      double rez = 0;
      for (int i = 0; i < 3; i++) { rez += integrnormal[i] * field[i]; }
      return rez;
    }
  };
\end{lstlisting}
\end{mybox}

\noindent
Now, in order to calculate the Gauss law integral, the above functor needs to be calculated for all domain boundary segments and integrated over the reference element (reference triangle for simplex meshes). Thus, the code iterates over all elements of the mesh, then over all intersections, then constructs the above functor using each intersection that does not have a neighbour, and integrates it over the reference element using the gradually approximating quadrature as given in \ref{interface-integrator-quadrature}. \\

\begin{mybox}
\begin{lstlisting}
  double gaussintegral = 0.0;
  double rel_tol = 1.0e-5;

  LeafGridView leafView = grid.leafGridView();
  EntityLeafIterator ibegin = leafView.template begin<0>();
  EntityLeafIterator iend   = leafView.template end<0>();

  for (EntityLeafIterator it = ibegin; it != iend; ++it)
  {
    const Entity &entity = *it;
    const IntersectionIterator nend = leafView.iend(entity);
    for( IntersectionIterator nit = leafView.ibegin(entity); nit != nend; ++nit )
    {
      const Intersection &intersection = *nit;

      if (!intersection.neighbor())
      {
        Dune::GeometryType gt = intersection.type();
        GaussFunctor<GridType, 2> f(intersection);
        Dune::QuadratureIntegrator<double, 2> qInt;
        double thisIntegral = qInt.integrateRecursive(gt, f, rel_tol).second;
        gaussintegral += thisIntegral;
      }
    }
  }
\end{lstlisting}
\end{mybox}





%\subsection{Tutorial 4 - Recursive Numerical Integration}
%\label{usage-howto-tutorial-integration-recursive}

\subsection{Tutorial 5 - Polynomial Manipulation and Integration}
\label{usage-howto-tutorial-polynomial}

\subsection{Tutorial 6 - Communication}
\label{usage-howto-tutorial-communication}


\subsection{Tutorial 7 - Point Location - OCTree}
\label{usage-howto-tutorial-octree}










