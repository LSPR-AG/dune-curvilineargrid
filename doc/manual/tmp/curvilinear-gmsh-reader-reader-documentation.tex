% Use only LaTeX2e, calling the article.cls class and 12-point type.

\documentclass[12pt]{article}

\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage[normalem]{ulem}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% The following parameters seem to provide a reasonable page setup.
\topmargin 0.0cm
\oddsidemargin 0.2cm
\textwidth 16cm 
\textheight 21cm
\footskip 1.0cm

% Rounded boxes functionality
\usepackage[framemethod=tikz]{mdframed}
\definecolor{mycolor}{rgb}{0.122, 0.435, 0.698}

\newmdenv[innerlinewidth=0.5pt, roundcorner=4pt,linecolor=mycolor, backgroundcolor=lightgray, innerleftmargin=6pt,
innerrightmargin=6pt,innertopmargin=6pt,innerbottommargin=6pt]{mybox}

% Include your paper's title here

\title{Curvilinear GMSH Reader} 
\author{Aleksejs Fomins}
\date{}

%%%%%%%%%%%%%%%%% END OF PREAMBLE %%%%%%%%%%%%%%%%

\begin{document} 

% Double-space the manuscript.
% \baselineskip24pt

% Make the title.
\maketitle 

\section{GMSH conventions}

\subsection{Structure of .msh files}

\begin{mybox}
\begin{lstlisting}
$MeshFormat
ver f_type data_size              # This line is mostly irrelevant
$EndMeshFormat
$Nodes
n_vertices
1 x y z
2 x y z
.......
n_vertices x y z
$EndNodes
$Elements
n_elem
1 elem_type n_tags (process_tags) v_1 v_2 ... v_N
2 elem_type n_tags (process_tags) v_1 v_2 ... v_N
.......
n_elem elem_type n_tags (process_tags) v_1 v_2 ... v_N
$EndElements
\end{lstlisting}
\end{mybox}

\noindent
where
\begin{itemize}
	\item $ver$             - version of the GMSH file
	\item $f\_type$          - type of file (irrelevant)
	\item $data\_size$       - size of file (irrelevant)
	\item $n\_vertices$      - number of vertices of the mesh
	\item $i\ x\ y\ z$         - index of the vertex and its coordinates
	\item $n\_elem$          - number of elements of the mesh
	\item $elem\_type$       - Integer which determines element type and interpolation order
	\item $n\_tags$          - Total number of tags. If $>2$, then have $process\_tags$
	\item $process\_tags$    - Tags which determine the process the vertex belongs to. Only if GMSH is told to partition the mesh
	\item $v\_1\ v\_2\ ...\ v\_N$ - Indices of interpolatory vertices associated with this element (includes corners)
\end{itemize}

\subsection{Convention for numbering interpolatory vertices}

\noindent
Each curvilinear element posesses a set of interpolatory vertices. For order 1 (linear elements) this is just the set of corners of the element, but for higher orders there are additional points located in on the inside of the elements, their faces and edges. To number these vertices, GMSH uses recursive conviention.

\begin{enumerate}
	\item First number all corners, then all edges, then all faces, then vertices inside element, then internal vertices of the element
	\item Inside edge, vertices are numbered sequentially
	\item For a triangle, the order of edges is $(0,1)$, $(1,2)$, $(2,0)$. (in 2D)
	\item For a tetrahedron, the order of edges is $(0,1)$, $(1,2)$, $(2,0)$, $(3,0)$, $(3,2)$, $(3,1)$.
	\item For a tetrahedron, the order of faces is $(0, 2, 1)$, $(0, 1, 3)$, $(0, 3, 2)$, $(3, 1, 2)$, including orientation
	\item If there are vertices associated with element itself(for example, on the triangle or inside the tetrahedron), a smaller element is created inside this triangle preserving its orientation, and is then numbered recursively.
\end{enumerate}

\noindent
Unfortunately, this convention does not match the grid convention used in DUNE, namely
\begin{mybox}
\begin{lstlisting}
for (z = 0 to 1, y = 0 to 1-z, x = 0 to 1-z-y) { vertex(x,y,z); }
\end{lstlisting}
\end{mybox}

\noindent
There is no good expression which maps from GMSH to DUNE convention, so it was implemented it by hand for simplex geometries up to order 5.
\begin{itemize}
	\item Triangle Order 1: \{0, 1, 2\}
	\item Triangle Order 2: \{0, 3, 1, 5, 4, 2\}
	\item Triangle Order 3: \{0, 3, 4, 1, 8, 9, 5, 7, 6, 2\}
	\item Triangle Order 4: \{0, 3, 4, 5, 1, 11, 12, 13, 6, 10, 14, 7, 9, 8, 2\}
	\item Triangle Order 5: \{0, 3, 4, 5, 6, 1, 14, 15, 18, 16, 7, 13, 20, 19, 8, 12, 17, 9, 11, 10, 2\}
	
	\item Tetrahedron Order 1: \{0, 3, 1, 2\}
	\item Tetrahedron Order 2: \{0, 7, 3, 4, 9, 1, 6, 8, 5, 2\}
	\item Tetrahedron Order 3: \{0, 11, 10, 3, 4, 17, 14, 5, 15, 1, 9, 18, 12, 16, 19, 6, 8, 13, 7, 2\}
	\item Tetrahedron Order 4: \{0, 15, 14, 13, 3, 4, 25, 27, 19, 5, 26, 20, 6, 21, 1, 12, 28, 29, 16, 22, 34, 31, 24, 32, 7, 11, 30, 17, 23, 33, 8, 10, 18, 9, 2\}
	\item Tetrahedron Order 5: \{0, 19, 18, 17, 16, 3, 4, 34, 39, 36, 24, 5, 37, 38, 25, 6, 35, 26, 7, 27, 1, 15, 40, 43, 41, 20, 28, 52, 55, 46, 33, 53, 49, 30, 47, 8, 14, 45, 44, 21, 31, 54, 51, 32, 50, 9, 13, 42, 22, 29, 48, 10, 12, 23, 11, 2\}
\end{itemize}












\section{Parallel Implementation}

The idea of parallel implementation is that all data - vertex coordinates, internal elements and boundary elements - are split between processes, not to exceed the single core memory. Thus the strategy for reading data on a process $i$ is as follows:
\begin{enumerate}
	\item Compute the total number $N_{elem}$ of non-boundary (internal) elements.
\end{enumerate}

\begin{mybox}
Loop over all elements in the file, and count the number of elements with dimension equal to the world dimension
\end{mybox}	
\begin{enumerate}[resume]	
	\item Read and store internal elements belonging to this process. If elements are split in consequent equal chunks among processes, then process $rank$ should read the elements with indices $interv(rank) = \floor[\Big]{ [rank, rank+1] \cdot N_{elem} / p_{tot} } + 1$.
\end{enumerate}

\begin{mybox}
\begin{itemize}
	\item Loop over all elements in the file
	\item Store all internal elements for which $index \in interv(rank)$
	\item Add global indices of vertices belonging to selected elements to a set
\end{itemize}

\end{mybox}		


\begin{enumerate}[resume]
	\item Read and store boundary elements belonging to this process - those which match the subentities of some elements.
\end{enumerate}
\begin{mybox}
	\begin{itemize}
		\item Only read the boundaries for which all \textbf{corners} have already been included to the element vertex set. 
	\end{itemize}
\end{mybox}	

\begin{enumerate}[resume]
	\item Read and store vertices belonging to this process. Namely, all the vertices that are necessary to construct the elements and boundaries belonging to 
this process.
	\begin{itemize}
		\item Local index of a vertex is a number $[0,n_p)$ where $n_p$ is the total number of vertices on the process.
		\item Local index of a vertex is given by the order they are inserted to the grid factory. It is in the ascending order of the global index, just that certain vertices of global index are not on this process. To keep track of this we fill the global-to-local map for vertices.
	\end{itemize}

	\item Add boundary elements to factory. It is necessary to connect the boundary elements to the internal elements they share a face with, because during load balance, the boundaries need to be communicated together with the corresponding elements.GMSH does not provide information on this interconnection.
	\begin{itemize}
		\item \uline{Important!} This must be done before adding internal elements to factory, as we also need to add the interconnection array.
		\item Add global element index as well
	\end{itemize}
\end{enumerate}

\begin{mybox}
\noindent
Currently using brute-force, because it is not much slower than improved for \\

\noindent
\uline{Trivial Algorithm: (Complexity $O(12 N_{elem} N_{\beta} / p_{tot}^2)$)}\\
\textit{Loop over all stored boundary elements $\beta_i$, and over all stored internal elements $E_j$.} \\
\textit{ If $\beta_i \in E_j$ for some $j$ then store $\beta_i$ }\\

\noindent
\uline{Improved Algorithm: (Complexity $O(12 N_{elem} \log_2 (N_{\beta} / p_{tot}) / p_{tot}$)}\\

\begin{enumerate}
	\item Construct map from boundary vertex index set to boundary id
	\item Add all boundaries to the map
	\item Loop over each face of all internal elements
	\begin{enumerate}
		\item If $map[face]$ is non-null, link the element and boundary
	\end{enumerate}
\end{enumerate}

\end{mybox}	
		
\begin{enumerate}[resume]
	\item Add internal elements to factory
\end{enumerate}
\begin{mybox}
	\begin{itemize}
		\item For debugging purposes write each element to a .vtk file using CurvilinearVTKWriter.
		\item Add element vertices and global element index to factory
		\item If creating grid with boundaries, also pass $internal\_to\_boundary\_element\_linker$. This array stores the indices of boundaries which are connected to this element (if any).
	\end{itemize}
\end{mybox}




















\section{Curvilinear VTK Writer}

\subsection{Implementation}

\begin{enumerate}
  \item For each tetrahedron, define interpolation class, which gives its global curved coordinates based on local parametric coordinates and interpolation points.
      \subitem - the interpolation points are passed only once when initialising the class
  \item parametrically Loop over all surfaces of the tetrahedron
      \subitem - Shrink the surfaces by a little bit for better visibility
      \subitem - Calculate a fixed number of equally spaced points on each face using square mesh, add all points to a map, which notes which points have already been added. This can be done either by using the interpolation class to get the interpolated points, or simply re-using the interpolation points not to invoke the interpolation process at all thus testing it.
      \subitem - Split each square into 2 triangles and add them to the triangle list. If the square is at the edge, it produces only 1 triangle.
  \item Write a .VTK file which has all triangles
\end{enumerate}


\subsection{Optimal Sampling Rate}

Here we would like to discuss how many sampling points are required to represent the bounded curve using linear interpolation. This is necessary, for example, for visualisation. For a line segment, interpolating the curve bounded by 2 points, the analytic error is bounded by
\begin{equation}
	\epsilon = |f(x) - g(x)| \leq \frac{1}{8} \max_{z \in [x_a, x_b]} \{ g''(z)  \} (x_a - x_b)^2
\end{equation}
\noindent
where $f(x)$ is the line segment, $g(x)$ is the original function. $x_a$ and $x_b$ are arguments of the endpoints of the interval. \\

\noindent
Given a large interval $L$ which we split into $N$ equal segments such that $x_b - x_a = L/N$, the maximal error over all interpolated intervals is bounded by
\begin{equation}
	\epsilon_{\max} \leq \frac{L^2}{8 N^2} \max_{z \in L} \{ g''(z) \}
\end{equation}
\noindent
This can be rewritten to obtain the necessary interval number per edge
\begin{equation}
	N = \biggl \lceil \alpha \sqrt{ \max_{z \in L} \{ g''(z) \} } \biggr \rceil
\end{equation}
\noindent
where $\alpha$ depends on precision and length of the interval. We observe that there is a problem with this formula, namely that if $g''(z) = 0$ we get 0 intervals, and if $g''(z)$ is small, we get 1 interval, and we would like 2, because there is at least some curvature, and it should be emphasized that the case is different from just straight line. Therefore we empirically modify the formula
\begin{equation}
	N = \biggl \lceil \alpha \sqrt{ \max_{z \in L} \{ g''(z) \} } + 1 \biggr \rceil
\end{equation}

\noindent
Finally, since this equation is not exactly accurate for surfaces, and it is rather hard to make sense of optimal relative error, it is much easier to choose $\alpha$ empirically. We will generally operate with unit length edges ($L = 1$), and would like to, for example, have 5 points per edge with standard quadratic curvature $g(x) = x^2$. We obtain that $\alpha \approx 2.8$. \\

\noindent
As a rule of thumb, we can calculate the expected number of intervals for a standard function $g(x) = \sum_i x^i$ using this formula. The first 5 orders will produce edge intervals $\{ 1, 5, 9, 17, 35\}$, which will correspond to the number of vertices per edge $\{ 2, 6, 10, 18, 36\}$, and thus the number of surface vertices ($i(i+1)/2$) will be given by $\{3, 21, 55, 171, 666\}$.




\section{CurvilinearGridFactory}

\subsection{Parallel Communication - Clink Protocol}

After running Partition step, the elements need to be communicated between the processes. The suggestions are
\begin{itemize}
	\item \uline{Andreas Dedner:} consider a callback approach similar to the one we are using for the repartitioning in ALUGrid. So the method createGrid gets a callback object which it can ask for a partition number to which to send the process. That would mean that the code would not be restricted to ParMetis.
	\item \uline{George Karypis:} Parmetis contain a function that moves a graph around based on the partitioning that is used internally. You may want to take a look at that code. It is in the file called move.c.
\end{itemize}

\noindent
We decided to implement our own protocol, which comes from classical toasting protocol or alternatively chess all-play-all tournaments (\url{http://en.wikipedia.org/wiki/Round-robin_tournament#Scheduling_algorithm}). The idea of this protocol is that each player plays every other player exactly one time, and the total number of rounds is minimal. \\

\noindent
We shall now adapt this algorithm to multiprocess communication and discuss its advantages and disadvantages. Let $size$ be the total number of processes, $r \in [0..size-1]$ be the rank of the current process, and $m \in [0..s-1]$ the round number. The total number of rounds $s$ that needs to be played is $s = size$ for odd size and $s = size - 1$ for even size. Then the above protocol can be rewritten to obtain the rank of the friend of this process $r_f(s,r,m)$\\

\begin{mybox}
1) If ($r == 0$) \{$r_f = s - 1 - m$\} \\ \indent  \;\;\;\;\; The case for master process \\
2) else \{$r_f = r + s - 3 - 2((r + m - 1)\mod (s - 1) )$ \} \\  \indent  \;\;\;\;\; The case for all other processes \\
3) If ($r_f == size$) \{ skip this element if it is not paired with anything \}
\end{mybox}

\noindent
Thus, each process can calculate the order in which it needs to communicate with other processes. Both communicating processes at every round use the safe $MPI\_EXCHANGE$ communication protocol to give each other elements that belong there.\\


\noindent
Advantages of this method:
\begin{itemize}
	\item No communication at all used to determine who communicates who.
	\item All processes communicate at the same time.
	\item No need to wait until the end of the round - if both processes are ready, they can communicate in the next round before some other processes have finished the previous rounds, thus different processes can be in different rounds of the communication.
	\item \textbf{TODO\:} See if a more greedy than standard $MPI\_SEND$ can be used to save computation time.
\end{itemize}

\noindent
Disadvantages
\begin{itemize}
	\item It may be advantageous to use some communication between processes to have an insight into fixing the communication order. The order in above protocol is paradigmatic - there is flexibility to modify it without changing the protocol itself.
	\item The communication need not only exchange necessary elements - it may be beneficial to exchange elements belonging to some other processes to communicate them to their owners faster. However, this should not be done one requires a priori knowledge 
\end{itemize}






\newpage
\appendix

\subsection{Calculate the average number of elements that are common to a point}

\textbf{Triangles}:
\begin{itemize}
	\item Average angle of a triangle $\gamma = \pi/3$.
	\item Average triangles per point $2\pi / \gamma = 6$
\end{itemize}
\noindent
\textbf{Tetrahedra}:
\begin{itemize}
	\item Average solid angle per tetrahedron $\gamma = 0.55$
	\item Average tetraherda per point $4\pi / \gamma \approx 23$
\end{itemize}

\subsection{Algorithm: Boundary-Internal element match search. Complexity Calculation}

\noindent
Let the total number of elements be $N_e$, with largest expected size $N_e \approx 10^7$.

\noindent
Want to approximate the number of boundary elements
\begin{itemize}
	\item Sphere: $V = 4\pi r^3 / 3$, $A = 4\pi r^2 \approx 7.79\ V^{2/3}$
	\item Cube: $V = r^3$, $A = 6 r^2 = 6\ V^{2/3}$
	\item Sheet: $V = \epsilon r^3$, $A = 2 r^2 + 4\epsilon r^2 \approx 2(1/\epsilon)^{2/3} V^{2/3}$
\end{itemize}
\noindent
So, $N_{\beta} = \alpha N_e^{2/3}$, where $\alpha \approx [10^1$ to $10^2]$ depending on how flat the computational domain is. \\

\noindent
For a simple algorithm, we would loop over all all boundaries and all elements, then over all points of each and compare.
The complexity of that is \[ 3*4 * (N_e / p_{tot}) * N_{\beta} = 12 \alpha N_e^{5/3} / p_{tot} \]

\noindent
For the complicated algorithm
\begin{itemize}
	\item For each element adding its name to the vertex map: $O(4 (N_e / p_{tot}) \log(N_e / p_{tot}) )$
	\item For each corner of each boundary access this map to get element set: $O(3 N_{\beta} \log(N_e / p_{tot}))$
	\item Intersecting 3 sets of indices, of length $M_T$: $O(2 * N_{\beta} 4M_T)$
\end{itemize}
\noindent
where $M_T$ for tetrahedra is approx $23$ as shown in the above section. This results for a total complexity

\[ N_e(    \log(N_e^{2/3} / p_{tot})(\frac{4 N_e^{1/3}}{p_{tot}} + 3 \alpha ) + 184 * \alpha)  \approx  N_e^{2/3} \alpha (3 \log(N_e / p_{tot}) + 184)  \]

\noindent
Conclusion
\begin{itemize}
	\item For small mesh with $10^4$ elements and $10^1$ processes, the complexities are $\sim 4.3\cdot 10^7$ and $\sim 7.6 \cdot 10^5$
	\item For large mesh with $10^7$ elements and $10^3$ processes, the complexities are $\sim 4.3\cdot 10^{10}$ and $\sim 8.0 \cdot 10^7$
\end{itemize}
\noindent
Therefore, the advanced method is essential






\end{document}